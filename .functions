#!/usr/bin/env bash

is-macos() {
    [[ "$OSTYPE" == darwin* ]]
}

what() {
    echo "CHEAT:"
    cheat "$1"
    echo "TLDR:"
    tldr "$1"
}

update() {
    echo "Updating Homebrew..."
    brew update

    echo "Upgrading Homebrew formulas..."
    brew upgrade

    echo "Upgrading Homebrew Cask formulas..."
    brew cask upgrade --greedy || true

    echo "Updating npm..."
    npm i -g npm

    echo "Updating global npm..."
    npm update -g

    echo "Updating global pip packages..."
    pip list --user --outdated --format freeze | xargs -n1 pip install --upgrade --user
}

alias upgrade=update

# Check if a program is installed
# $1: name of command to check for
# $2: URL for information on installing the command
check-installed() {
    if [[ -z "$(command -v "$1")" ]]; then
        echo "error: could not find $1, please install it before trying again"
        if [[ -n "$2" ]]; then
            echo "       $2"
        fi
        return 1
    fi
}

# Push the current branch and create a pull request:
# - with the current GitHub user assigned
# - with the commit messages in a Markdown-formatted list in the description
# - copy the link to the clipboard
# - open it in a browser
# - pass all other arguments directly to `hub pull-request`
pr() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    git push --set-upstream

    GITHUB_USER="$(git config github.user)"

    # Get value of -b/--branch flag if passed; otherwise use default branch
    BASE_BRANCH="$(get-default-branch origin)"
    BRANCH_FLAG_PATTERN='(-b |--branch |-b=|--branch=)([a-zA-z0-9[:punct:]]+)'
    if [[ "$@" =~ $BRANCH_FLAG_PATTERN ]]; then
        BASE_BRANCH="${match[2]}"
    fi

    # Subject, followed by a newline, followed by the body with every line indented by two spaces
    readonly COMMIT_FORMAT='format:- %s%n%w(0,2,2)%b'
    COMMITS="$(git log "$BASE_BRANCH"..HEAD --pretty="$COMMIT_FORMAT")"
    MESSAGE="

$COMMITS"

    # Run dynamically constructed command, using $@ to pass it all arguments
    hub pull-request --browse --copy --message="$MESSAGE" --edit ${GITHUB_USER:+'--assign='"$GITHUB_USER"} "$@"
}

# Watch continuous integration for the current HEAD commit, printing out status as it changes
watch-ci() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    local ci_status
    ci_status="$(hub ci-status)"
    local ci_status_all
    ci_status_all="$(hub ci-status -v)"
    echo "$ci_status_all"

    # Check CI status every five seconds, terminate loop if it is no longer pending
    while [ "$ci_status" = "pending" ]; do
        sleep 5

        # Check if the status of individual checks has changed, only log them if it has
        local ci_status_all_new
        ci_status_all_new="$(hub ci-status -v)"
        if [ "$ci_status_all" != "$ci_status_all_new" ]; then
            ci_status_all="$ci_status_all_new"
            echo
            echo "Status updated:"
            echo "$ci_status_all"
        fi

        ci_status="$(hub ci-status)"
    done
    
    local project
    project="$(basename "$(pwd)")"
    if is-macos; then
        osascript -e "display notification \"The build for $project is complete.\" with title \"watch-ci\""
    fi
}

# Wait for continuous integration to finish, refreshing at a set interval, then print out the list of releases
# $1: 'prod' to only get production releases or 'beta' to only get beta releases
get-release() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    PREV_RELEASES=""

    # If CI status is pending, get current list of releases then wait for CI to finish
    if [[ "$(hub ci-status)" == "pending" ]]; then
        # Get current list of releases, which will be diffed against later to show the new version
        PREV_RELEASES="$(hub release)"

        echo "Waiting for CI..."
        watch-ci
    fi

    # Print list of releases, diffing against previous list of releases if it is set
    if [[ -n "$PREV_RELEASES" ]]; then
        echo
        echo "New release:"
        # Diff, only displaying changed groups, and hiding any control characters
        diff \
            --ignore-all-space \
            --changed-group-format='%<%>' \
            --unchanged-group-format='' \
            <(echo "$PREV_RELEASES") <(hub release)
    else
        echo "All releases:"
        RELEASES="$(hub release)"
	if [[ "$1" = "prod" ]]; then
	    RELEASES="$(echo "$RELEASES" | grep 'v[0-9]*\.[0-9]*\.[0-9]*$')"
	elif [[ "$1" = "beta" ]]; then
	    RELEASES="$(echo "$RELEASES" | grep 'v[0-9]*\.[0-9]*\.[0-9]*-beta.[0-9]*$')"
	fi
	echo "$RELEASES"
    fi
}

# Get the default branch of the repository (for a specific remote)
# $1: name of a remote (defaults to "origin")
get-default-branch() {
    remote=${1:-origin}
    git symbolic-ref --short refs/remotes/"$remote"/HEAD | sed "s/$remote\///"
}

# Merge the latest upstream changes into the current branch
# $1: branch name to fetch (defaults to "develop")
# $2: name of remote to fetch from (defaults to "origin")
merge-latest() {
    DEFAULT_BRANCH="$(get-default-branch origin)"
    BRANCH=${1:-"$DEFAULT_BRANCH"}
    REMOTE=${2:-origin}
    git fetch "$REMOTE" "$BRANCH"
    git merge --no-edit "$REMOTE"/"$BRANCH"
}


# Move back to the default branch, pull, prune branches, and remove the previous branch
clean-up-branch() {
    CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    DEFAULT_BRANCH="$(get-default-branch origin)"

    if [[ "$CURRENT_BRANCH" == "$DEFAULT_BRANCH" ]]; then
        echo "error: current branch is default branch, please run again from a different branch"
        return 1
    fi

    git checkout "$DEFAULT_BRANCH"
    git pull
    git fetch --prune
    git branch --delete "$CURRENT_BRANCH"
}

# Move back to the default branch, merge the previous branch, push, remove the previous branch, then remove the previous branch from the remote
merge-pr() {
    CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    DEFAULT_BRANCH="$(get-default-branch origin)"
    BASE_BRANCH="$(hub pr list --head="$CURRENT_BRANCH" --limit=1 --format='%B')"
    TITLE="$(hub pr list --head="$CURRENT_BRANCH" --limit=1 --format='%t')"

    if [[ "$CURRENT_BRANCH" == "$DEFAULT_BRANCH" ]]; then
        echo "error: current branch is default branch, please run again from a different branch"
        return 1
    fi

    BRANCH="$DEFAULT_BRANCH"
    if [[ -n "$BASE_BRANCH" ]]; then
         BRANCH="$BASE_BRANCH"
    fi

    MESSAGE=""
    if [[ -n "$TITLE" ]]; then
        MESSAGE="--message=$TITLE"
    fi

    # After checking out the base branch, ensure it is up to date with its remote counterpart
    if git pull && \
       git checkout "$BRANCH" && \
       merge-latest "$BRANCH" && \
       git merge --no-ff "$CURRENT_BRANCH" "$MESSAGE" && \
       git push; then
        # Only delete branches if all operations succeed
        git branch --delete "$CURRENT_BRANCH"
        git push origin --delete "$CURRENT_BRANCH"
    fi
}

# Log all commits on the current branch that are not on the default branch.
log-branch-commits() {
    git log "$(get-default-branch)"..HEAD --oneline
}

# Get all Jira ticket IDs mentioned in commits in develop that are not in master
get-tickets() {
    git fetch --all > /dev/null
    git log origin/master..origin/develop --extended-regexp --grep 'TOOLS|APPS' --pretty=oneline | grep -Po '(APPS|TOOLS)-[0-9]+' | uniq -u
}

# Find the current randomized name of a pod for an application
# $1: namespace
# $2: application name
kube-pod() {
    kubectl get pods --output json --namespace "$1" | jq --arg app "$2" '.items[] | select(.metadata.labels.app == $app).metadata.name'
}

# Get all peer dependencies for a given package as a string suitable for input to `npm install`
# $1: name of package installed in current project's node_modules
get-peer-dependencies() {
    jq --raw-output \
    '.peerDependencies | to_entries | map("\(.key)@\(.value)") | join(" ")' \
    "./node_modules/$1/package.json"
}

# Install all peer dependencies for a given package
# $1: name of package installed in current project's node_modules
install-peer-dependencies() {
    npm install $(get-peer-dependencies "$1")
}
