#!/bin/bash

what() {
    printf "%s\\n" "CHEAT:"
    cheat "$1"
    printf "%s\\n" "TLDR:"
    tldr "$1"
}

update() {
    printf "%s\\n" "Updating Homebrew..."
    brew update

    printf "%s\\n" "Upgrading Homebrew formulas..."
    brew upgrade

    printf "%s\\n" "Upgrading Homebrew Cask formulas..."
    brew cask upgrade --greedy || true

    printf "%s\\n" "Updating npm..."
    npm i -g npm

    printf "%s\\n" "Updating global npm..."
    npm update -g

    printf "%s\\n" "Updating global pip packages..."
    pip list --user --outdated --format freeze | xargs -n1 pip install --upgrade --user
}

alias upgrade=update

# Check if a program is installed
# $1: name of command to check for
# $2: URL for information on installing the command
check-installed() {
    if [[ -z "$(command -v "$1")" ]]; then
        printf "%s\\n" "error: could not find $1, please install it before trying again"
        if [[ -n "$2" ]]; then
            printf "       %s\\n" "$2"
        fi
        return 1
    fi
}

# Push the current branch and create a pull request:
# - with the current GitHub user assigned
# - copy the link to the clipboard
# - open it in a browser
# - pass all other arguments directly to `hub pull-request`
pr() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    git push --set-upstream

    CMD="hub pull-request --browse --copy"

    GITHUB_USER="$(git config github.user)"
    if [[ "$GITHUB_USER" ]]; then
        CMD="$CMD --assign=$GITHUB_USER"
    fi

    # Run dynamically constructed command, using $@ to pass it all arguments
    eval "$CMD" "$@"
}

# Watch continuous integration for the current HEAD commit, printing out status as it changes
watch-ci() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    CI_STATUS="$(hub ci-status)"
    CI_STATUS_ALL="$(hub ci-status -v)"
    printf "%s\\n" "$CI_STATUS_ALL"

    # Check CI status every five seconds, terminate loop if it is no longer pending
    while [[ "$CI_STATUS" == "pending" ]]; do
        sleep 5

        # Check if the status of individual checks has changed, only log them if it has
        CI_STATUS_ALL_NEW="$(hub ci-status -v)"
        if [[ "$CI_STATUS_ALL" != "$CI_STATUS_ALL_NEW" ]]; then
            CI_STATUS_ALL="$CI_STATUS_ALL_NEW"
            printf "\\n%s\\n" "Status updated:"
            printf "%s\\n" "$CI_STATUS_ALL"
        fi

        CI_STATUS="$(hub ci-status)"
    done
}

# Wait for continuous integration to finish, refreshing at a set interval, then print out the list of releases
get-release() {
    if ! check-installed hub https://hub.github.com/; then
        return 1
    fi

    PREV_RELEASES=""

    # If CI status is pending, get current list of releases then wait for CI to finish
    if [[ "$(hub ci-status)" == "pending" ]]; then
        # Get current list of releases, which will be diffed against later to show the new version
        PREV_RELEASES="$(hub release)"

        printf "%s\\n" "Waiting for CI..."
        watch-ci
    fi

    # Print list of releases, diffing against previous list of releases if it is set
    if [[ -n "$PREV_RELEASES" ]]; then
        printf "\\n%s\\n" "New release:"
        # Diff, only displaying changed groups, and hiding any control characters
        diff \
            --ignore-all-space \
            --changed-group-format='%<%>' \
            --unchanged-group-format='' \
            <(printf "%s\\n" "$PREV_RELEASES") <(hub release)
    else
        printf "%s\\n" "All releases:"
        hub release
    fi
}

# Merge the latest upstream changes into the current branch
# $1: branch name to fetch (defaults to "develop")
# $2: name of remote to fetch from (defaults to "origin")
merge-latest() {
    BRANCH=${1:-develop}
    REMOTE=${2:-origin}
    git fetch "$REMOTE" "$BRANCH"
    git merge "$REMOTE"/"$BRANCH"
}

# Get the default branch of the repository (for a specific remote)
# $1: name of a remote (defaults to "origin")
get-default-branch() {
    REMOTE=${1:-origin}
    git remote show "$REMOTE" | grep "HEAD branch" | sed 's/.*: *//'
}

# Move back to the default branch, pull, prune branches, and remove the previous branch
clean-up-branch() {
    CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    DEFAULT_BRANCH="$(get-default-branch origin)"

    if [[ "$CURRENT_BRANCH" == "$DEFAULT_BRANCH" ]]; then
        printf "%s\\n" "error: current branch is default branch, please run again from a different branch"
        return 1
    fi

    git checkout "$DEFAULT_BRANCH"
    git pull
    git fetch --prune
    git branch --delete "$CURRENT_BRANCH"
}
