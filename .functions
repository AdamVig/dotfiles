#!/bin/bash

what() {
    printf "%s\\n" "CHEAT:"
    cheat "$1"
    printf "%s\\n" "TLDR:"
    tldr "$1"
}

update() {
    printf "%s\\n" "Updating Homebrew..."
    brew update

    printf "%s\\n" "Upgrading Homebrew formulas..."
    brew upgrade

    printf "%s\\n" "Upgrading Homebrew Cask formulas..."
    brew cask upgrade --greedy || true

    printf "%s\\n" "Updating npm..."
    npm i -g npm

    printf "%s\\n" "Updating global npm..."
    npm update -g

    printf "%s\\n" "Updating global pip packages..."
    pip list --user --outdated --format freeze | xargs -n1 pip install --upgrade --user
}

alias upgrade=update

# Push the current branch and create a pull request:
# - with the current GitHub user assigned
# - copy the link to the clipboard
# - open it in a browser
# - pass all other arguments directly to `hub pull-request`
pr() {
    git push --set-upstream

    CMD="hub pull-request --browse --copy"

    GITHUB_USER="$(git config github.user)"
    if [[ "$GITHUB_USER" ]]; then
        CMD="$CMD --assign=$GITHUB_USER"
    fi

    # Run dynamically constructed command, using $@ to pass it all arguments
    eval "$CMD" "$@"
}

# Watch continuous integration for the current HEAD commit, printing out status as it changes
watch-ci() {
    CI_STATUS_ALL="$(hub ci-status -v)"
    printf "%s\\n" "$CI_STATUS_ALL"

    # Check CI status every five seconds, terminate loop if it is no longer pending
    while [[ "$CI_STATUS" == "pending" ]]; do
        sleep 5

        # Check if the status of individual checks has changed, only log them if it has
        CI_STATUS_ALL_NEW="$(hub ci-status -v)"
        if [[ "$CI_STATUS_ALL" != "$CI_STATUS_ALL_NEW" ]]; then
            CI_STATUS_ALL="$CI_STATUS_ALL_NEW"
            printf "\\n%s\\n" "Status updated:"
            printf "%s\\n" "$CI_STATUS_ALL"
        fi

        CI_STATUS="$(hub ci-status)"
    done
}

# Wait for continuous integration to finish, refreshing at a set interval, then print out the list of releases
get-release() {
    # Check if Hub is installed
    if [[ -z "$(command -v hub)" ]]; then
        printf "%s\\n" "error: could not find hub, please install it before trying again"
        return 1
    fi

    PREV_RELEASES=""
    RELEASES=""

    # If CI status is pending, get current list of releases then wait for CI to finish
    CI_STATUS="$(hub ci-status)"
    if [[ "$CI_STATUS" == "pending" ]]; then
        # Get current list of releases, which will be diffed against later to show the new version
        PREV_RELEASES="$(hub release)"

        printf "%s\\n" "Waiting for CI..."
        watch-ci
    fi

    # Print list of releases, diffing against previous list of releases if it is set
    if [[ -n "$PREV_RELEASES" ]]; then
        printf "\\n%s\\n" "New release:"
        # Diff, only displaying changed groups, and hiding any control characters
        diff \
            --ignore-all-space \
            --changed-group-format='%<%>' \
            --unchanged-group-format='' \
            <(printf "%s\\n" "$PREV_RELEASES") <(hub release)
    else
        printf "%s\\n" "All releases:"
        hub release
    fi
}

# Merge the latest upstream changes into the current branch
# $1: branch name to fetch (defaults to "develop")
# $2: name of remote to fetch from (defaults to "origin")
merge-latest() {
    BRANCH=${1:-develop}
    REMOTE=${2:-origin}
    git fetch "$REMOTE" "$BRANCH"
    git merge "$BRANCH"
}
