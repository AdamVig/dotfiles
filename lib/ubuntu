#!/usr/bin/env bash

_dir="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"

# shellcheck source=./lib/helpers
source "$_dir"/helpers

log() {
	log_with_component ubuntu "$@"
}

# shellcheck disable=SC2119
request-sudo

log_start 'setting up Ubuntu'

log_start 'updating snaps'
if ! request-sudo snap refresh >/dev/null; then
	fatal 'failed to update snaps'
fi
log_end

declare -a snaps=(
	'authy --beta'
	ffsend
	standard-notes
	yq
)

for snap_raw in "${snaps[@]}"; do
	read -ra snap <<<"$snap_raw"
	log_start "installing snap '${snap[0]}'"
	if ! request-sudo snap install "${snap[@]}"; then
		fatal 'failed to install'
	fi
	log_end
done

log_start 'installing GitHub CLI completions'
install -D <(gh completion --shell zsh) "$HOME"/.local/share/gh/_gh
log_end

log_start 'linking batcat to bat'
ln -sf /usr/bin/batcat "$HOME"/.local/bin/bat
log_end

log_start 'linking fdfind to fd'
ln -sf /usr/bin/fdfind "$HOME"/.local/bin/fd
log_end

log_start 'configuring Grub'
log_start 'disabling generation of recovery options'
request-sudo sed -i 's|#GRUB_DISABLE_RECOVERY="true"|GRUB_DISABLE_RECOVERY="true"|' /etc/default/grub
log_end

grub_theme_dir=/boot/grub/themes/adamvig
if ! [ -f "$grub_theme_dir"/theme.txt ]; then
	log_start 'linking theme'
	request-sudo mkdir -p "$grub_theme_dir"
	request-sudo ln -sf "$_dir"/../config/grub-theme.txt "$grub_theme_dir"/theme.txt
	log_end
fi

grub_font_output_path="$grub_theme_dir"/opensans-regular.pf2
if ! [ -f "$grub_font_output_path" ]; then
	log_start 'converting font'
	opensans_path='/usr/share/fonts/truetype/open-sans/OpenSans-Regular.ttf'
	if ! request-sudo grub-mkfont --output "$grub_font_output_path" --size 36 "$opensans_path"; then
		fatal 'failed to convert font'
	fi
	log_end
fi

grub_theme_variable="GRUB_THEME=$grub_theme_dir/theme.txt"
if ! grep --quiet "$grub_theme_variable" /etc/default/grub; then
	log_start 'enabling theme'
	if ! echo "$grub_theme_variable" | request-sudo tee --append /etc/default/grub >/dev/null; then
		fatal 'failed to enable theme'
	fi
	log_end
fi

log_start 're-generating Grub configuration'
request-sudo update-grub
log_end
log_end

log_start 'updating user directories'
declare -A user_directories=(
	[DESKTOP]="$HOME"/desktop
	[DOWNLOAD]="$HOME"/downloads
	[TEMPLATES]="$HOME"/templates
	[PUBLICSHARE]="$HOME"/public
	[DOCUMENTS]="$HOME"/documents
	[MUSIC]="$HOME"/music
	[PICTURES]="$HOME"/pictures
	[VIDEOS]="$HOME"/videos
)
for user_directory_name in "${!user_directories[@]}"; do
	user_directory_path="${user_directories[$user_directory_name]}"

	if ! [ -d "$user_directory_path" ]; then
		user_directory_basename="$(basename "$user_directory_path")"
		user_directory_path_capitalized="$HOME"/"${user_directory_basename^}"
		if [ -d "$user_directory_path_capitalized" ]; then
			log "moving '$user_directory_path_capitalized' to '$user_directory_path'"
			mv "$user_directory_path_capitalized" "$user_directory_path"
		else
			log "creating '$user_directory_path'"
			mkdir -p "$user_directory_path"
		fi
	fi

	log "setting '$user_directory_name' to '$user_directory_path'"
	xdg-user-dirs-update --set "$user_directory_name" "$user_directory_path"
done
log_end

config_dir="$(xdg_config)"
mkdir -p "$config_dir"/i3
ln -sf "$_dir"/../config/i3 "$config_dir"/i3/config

mkdir -p "$config_dir"/i3blocks
ln -sf "$_dir"/../config/i3blocks "$config_dir"/i3blocks/config

mkdir -p "$config_dir"/redshift
ln -sf "$_dir"/../config/redshift.conf "$config_dir"/redshift/redshift.conf

mkdir -p "$config_dir"/pulse
ln -sf "$_dir"/../config/pulseaudio-configuration-script.pa "$config_dir"/pulse/default.pa

mkdir -p "$config_dir"/i3/workspaces
if ! [ -x "$config_dir"/i3/workspaces/init ]; then
	log_start 'initializing workspace initialization script'
	touch "$config_dir"/i3/workspaces/init
	chmod +x "$config_dir"/i3/workspaces/init
	log_end
fi

if ! [ -x "$config_dir"/i3/login-local ]; then
	log_start 'initializing local login script'
	touch "$config_dir"/i3/login-local
	chmod +x "$config_dir"/i3/login-local
	log_end
fi

xresources_path="$HOME"/.Xresources
if ! [ -f "$xresources_path" ]; then
	log_start 'writing .Xresources file'
	# Set display DPI
	echo 'Xft.dpi: 128' >"$xresources_path"
	log_end
fi

x11vnc_unit_path=/etc/systemd/system/x11vnc.service
if ! request-sudo [ -f "$x11vnc_unit_path" ]; then
	log_start 'creating x11vnc Systemd unit'
	echo '[Unit]
Description="x11vnc"
Requires=display-manager.service
After=display-manager.service

[Service]
ExecStart=/usr/bin/x11vnc -xkb -noxrecord -noxfixes -noxdamage -display :0 -auth guess
ExecStop=/usr/bin/killall x11vnc
Restart=on-failure
Restart-sec=2

[Install]
WantedBy=multi-user.target
' | request-sudo tee "$x11vnc_unit_path" >/dev/null
	request-sudo systemctl daemon-reload
	log_end
fi

if ! request-sudo systemctl is-enabled --quiet x11vnc.service; then
	log_start 'setting up x11vnc service'
	request-sudo systemctl enable --now x11vnc.service
	log_end
fi

log_start 'configuring GNOME Keyring'
# Create customized versions of the desktop files for the secrets and SSH components so they start automatically
# By default, the OnlyShowIn lines in the desktop files would prevent these components from being started
sed '/^OnlyShowIn.*$/d' /etc/xdg/autostart/gnome-keyring-secrets.desktop >"$config_dir"/autostart/gnome-keyring-secrets.desktop
sed '/^OnlyShowIn.*$/d' /etc/xdg/autostart/gnome-keyring-ssh.desktop >"$config_dir"/autostart/gnome-keyring-ssh.desktop
log_end

log_start 'disabling input language icon in system tray'
gsettings set org.freedesktop.ibus.panel show-icon-on-systray false
log_end

home_assistant_daemon_unit_path="$(xdg_config)"/systemd/user/home-assistant-daemon.service
if ! [ -f "$home_assistant_daemon_unit_path" ]; then
	home_assistant_daemon_environment_file_path="$(xdg_config)"/home-assistant-daemon.env
	if ! [ -f "$home_assistant_daemon_environment_file_path" ]; then
		log_start 'creating Home Assistant daemon environment file'
		echo '# Home Assistant daemon environment variables, in the format of a Systemd unit EnvironmentFile
# Hostname of Home Assistant instance
HOME_ASSISTANT_HOST=example.com
# API token for Home Assistant instance
HOME_ASSISTANT_TOKEN=
' >"$home_assistant_daemon_environment_file_path"
		log_end
		warn "Home Assistant daemon configuration created at $home_assistant_daemon_environment_file_path, open the file and fill in the values"
	fi

	log_start 'creating Home Assistant daemon Systemd unit'
	echo "[Unit]
Description=\"Home Assistant Daemon\"

[Service]
EnvironmentFile=$home_assistant_daemon_environment_file_path
ExecStart=$(realpath "$_dir"/../bin/home-assistant-daemon)

[Install]
WantedBy=default.target
" >"$home_assistant_daemon_unit_path"
	systemctl --user daemon-reload
	log_end
fi

if ! systemctl --user is-enabled --quiet home-assistant-daemon.service; then
	log_start 'setting up Home Assistant daemon'
	systemctl --user enable --now home-assistant-daemon.service
	log_end
fi

log_end
