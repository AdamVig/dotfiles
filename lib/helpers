#!/usr/bin/env bash

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail

black="$(tput setaf 0)"
blue="$(tput setaf 4)"
bold="$(tput bold)"
dim="$(tput dim)"
red_background="$(tput setab 1)"
reset="$(tput sgr0)"
standout="$(tput smso)"
yellow_background="$(tput setab 3)"

# FILO (first in, last out) array of operation names passed to log_start
log_operation_names=()

# Internal function for generating indentation based on length of log_operation_names array
_get_operation_indentation() {
	operation_depth="${#log_operation_names[@]}"
	if [ "$operation_depth" = 0 ]; then
		return
	fi

	# Subtract one to avoid indenting when only one operation is in the array
	num_spaces="$(((operation_depth - 1) * 2))"
	printf "%${num_spaces}s"
}

# Internal function intended to be called only by other logging functions
# Allows scripts to either `log` directly or redefine it to use `log_with_component` without causing an infinite loop
_log_internal() {
	# Redirect to stderr so output appears even when stdout is redirected
	echo >&2 "${dim}dotfiles${reset}" "$@"
}

# Log a message
# $@: passed to echo
log() {
	_log_internal "$@"
}

# Log the beginning of an operation
# $1: name of an operation
# $@: passed to log
log_start() {
	operation_name="${1:-}"
	if [ -z "$operation_name" ]; then
		echo 'internal error: log_start called without an operation name'
		return 1
	fi
	shift
	log_operation_names+=("$operation_name")

	log "${bold}start${reset}" "$operation_name" "$@"
}

# Log the end of an operation
# Automatically retrieves the name of the current operation from the array log_operation_names
log_end() {
	operation_name="${log_operation_names[-1]}"
	if [ -z "$operation_name" ]; then
		echo 'internal error: log_end called with nothing in progress'
		return 1
	fi

	log "${bold}end  ${reset}" "$operation_name"

	# Remove the current operation from the list
	unset -v 'log_operation_names[-1]'
}

# Log a message including the name of the component (usually the file where the log line is from)
# $1: component name
# $@: passed to log
log_with_component() {
	component="${1:-}"
	if [ -z "$component" ]; then
		echo 'internal error: log_with_component called without a component'
		return 1
	fi
	shift

	indent="$(_get_operation_indentation)"
	_log_internal "${blue}${component}${reset}${indent}" "$@"
}

# Log a warning message
# $@: passed to log
warn() {
	log "${black}${yellow_background} warning ${reset}" "$@"
}

# Log an error message
# $@: passed to log
error() {
	log "${black}${red_background} error ${reset}" "$@"
}

# Log an error message and exit with an error code
# $@: passed to error
fatal() {
	error "$@"
	exit 1
}

# Confirm if a user wants to do something
# Bypasses the prompt and proceeds if the variable SHOULD_CONFIRM is set to 0
# $1: message, defaults to 'Proceed?'
# returns 0 or 1 depending on user input, 0 means no, 1 means yes
confirm() {
	# Whether or not to skip prompt
	# Use value of SHOULD_CONFIRM; if not set, default to 1 (skip prompt)
	SHOULD_PROMPT=${SHOULD_CONFIRM:-1}
	if [[ $SHOULD_PROMPT == 1 ]]; then
		return 0 # automatic yes
	fi

	MESSAGE=${1:-"Proceed?"}
	read -p "$MESSAGE (y/n) " -n 1 -r
	echo
	[[ $REPLY =~ ^[Yy]$ ]] # REPLY is automatically set to the result of `read`
	return $?              # result of previous line, either 0 (yes) or 1 (no)
}

# cURL wrapper with common default options
_curl() {
	curl --silent --fail --show-error --location "$@"
}

# ln wrapper with common default options
_ln() {
	# Use short flags for portability
	# -s: make symbolic links instead of hard links
	# -f: overwrite link if it already exists
	# -r: make links relative to link location
	ln \
		-s \
		-f \
		-r \
		"$@"
}

# Get the GitHub release URL matching a given pattern
# $1: repository URL in format: [owner]/[repo name]
# $2: pattern to match
get_release_url() {
	repository="${1:-}"
	pattern="${2:-}"
	# Check if jq is available for JSON parsing
	if ! command -v jq >/dev/null; then
		warn "could not get release url for $1 because jq is not installed"
		return 100
	fi

	# Get list of releases
	curl -s "https://api.github.com/repos/${repository}/releases/latest" |
		jq --arg pattern "$pattern" --raw-output \
			'.assets | map(.browser_download_url | select(contains($pattern))) | first'
}

# Install a binary to ~/.local/bin from a URL
# $1: binary name
# $2: URL
install_binary_from_url() {
	local name="${1:-}"
	local url="${2:-}"
	local path="$HOME"/.local/bin/"$name"

	if ! _curl "$url" --output "$path"; then
		fatal "failed to download '$name' from '$url'"
	fi

	chmod +x "$path"
}

is_linux() {
	[[ $OSTYPE == *linux* ]]
}

is_macos() {
	[[ $OSTYPE == darwin* ]]
}

is_ubuntu() {
	command -v lsb_release >/dev/null && [ "$(lsb_release --id --short)" = 'Ubuntu' ]
}

# Prompt the user for their password with a custom message
# If any arguments are provided, they will be passed to sudo
# If no arguments are provided, update the user's cached credentials and extend the sudo timeout for five minutes
request_sudo() {
	# Redirect stderr to stdout so the output can be captured
	prompt="$(log 2>&1 "${standout} input ${reset}" 'Enter the system password for user %p: ')"
	if [ $# -eq 0 ]; then
		sudo --validate --prompt "$prompt"
	else
		sudo --prompt "$prompt" "$@"
	fi
}

xdg_config() {
	echo "${XDG_CONFIG_HOME:-$HOME/.config}"
}

xdg_data() {
	echo "${XDG_DATA_HOME:-$HOME/.local/share}"
}

xdg_cache() {
	echo "${XDG_CACHE_HOME:-$HOME/.cache}"
}
